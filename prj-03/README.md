# 第3章
　前回、ALUを実装したが、見返すと無駄があるので今後の課題としたい。  

## プリミティブなゲート　D型フリップフロップ
　Nandと同様にD型フリップフロップを最小単位として実装をしていく。

仕様は、tools/builtInChips/DFF.hdlを覗いてみると、
```
    CHIP DFF {
        In in;
        OUT out;
```
となっていたので。これを使って実装していく。

しかし、本とファイルの指定通り、
```
    BUILTIN Mux;
```
書くとうまく動かない。これをコメントアウトすると動く。暗黙的にビルトインチップを使用してくれるのであればいいのだが。ひとまずテストはうまくいくので暗黙的に使ってくれていると思っておく。  
(単純に同一ディレクトリになかったらビルトインチップを使うということだろうか)

## メモリのkについて
読んだのが1日以上空いていたので少し思い出すのに時間がかかた。念のためにメモする。  

メモリにアクセスする際に番号を指定する。その際のメモリの番号を指定するためにkという値を使う。例えばRAM8であれば、レジスタの数が8である。ゆえに番号は0\~7番。よってこの範囲を表す2進数は、0\~2^-1となる。ゆえにレジスタ番号を表す数は3ビットの2進数で表すことができる。ゆえにRAM8ではkが3となるのだ。

また、ややこしいがaddress\[k\]となっているがこれはあくまで3ビットの2進数という意味以上でも以下でもない。そこまで深い意味はないので深読みしないように注意したい。問題はこの3ビットの2進数をどう受け取って処理するかが重要である。(冷静に考えるとデマルチプレクサを使うだけだったのでそこまで難しくないと思う。)

## 内部バスを定義する方法はないのか？
バス出力から内部バスを定義することはできる。しかしピン出力に対して内部バスの1つを割り当てるように定義してもエラーが出る。本を読んでもチュートリアルにも書いていないみたいなので現状は長いのを書くしかなさそう。

## 実装
実装の手順をメモする。提供されているひな形のディレクトリaから実装していく。
1. 1bitレジスタ  -> Bit
1. 16bitレジスタ -> Register
1. メモリ -> RAM8
1. メモリ -> RAM64
1. カウンタ -> PC
1. メモリ -> RAM512
1. メモリ -> RAM4K
1. メモリ -> RAM16K

## 実装完了
　今回はほとんど同じ構造のものが多いのでそこまで難しくなかったが、意外とプログラムカウンタが難しかった。一応実装はできたが一見無駄が多いように見える。最適化できればいいが、それはまた別の機会にするとして次に進むとする。また今回きになったのはRAM4Kのテストをしているときに謎のコンソール出力が出ることだ。テスト自体は問題なく終了していること、よりメモリ数が多いRAM16Kの時にそのエラーが出ないことから実装自体はあっていると思うが少し気になる。