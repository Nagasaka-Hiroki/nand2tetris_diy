# 第2章
　今回も回路を実装していく。

実装の順番をメモする。

1. 半加算器 -> HalfAdder
2. 全加算器 -> FullAdder
3. 加算器   -> Add16
4. インクリメンタ -> Inc16　（もっと簡単な方法はないだろうか？、ひとまずテストコードは問題なかったので次に進む ->※）
5. ALU

## 細かいことのメモ
- ピン入力にtrueとfalseが使えるということが重要。  
前章で使っていなかったので忘れていた。  

- falseは0であるこれはいい。16ビットになっても0000 0000 0000 0000 となる（はず…。）  
しかし、どうやらtrueは1ビットでは1だが16ビットだと、 1111 1111 1111 1111 となるようだ。これをうまく使う必要がある。

- ※インクリメンタを簡単に実装できたのでメモする。
単純にバスは個別に入力、出力できることを忘れていた。以下に実装を示す。  
```
Add16( a=in, b[0]=true, b[1..15]=false, out=out);
```

しかし、迷走した解答もなかなかおもしろかったのでREADME.mdに書いてみる。  
以下迷走した解答。PARTS:　の部分のみ記載。

```
インクリメンタ（別解）
    /*
        定数入力true==(1111 1111 1111 1111)をうまく使う。
        trueは全ビットが1で構成される。そのため補数表現では-1になる。
        そのため、+1を実装することは難しいが、-1をすることは簡単である（Add16を使えば）。
        また、補数表現の作り方にも着目する。補数の作り方は以下のとおりである。
        
        xの補数は、xの全ビットを反転する、つまり論理否定演算Notをし、結果に+1をする。
        すなわち、
        -x == !x + 1
        である。
        
        この式から以下のことがわかる。
        !x == -(x+1)　....(※)
        すなわち、xの全ビット反転(論理否定)はx+1の補数を計算することになる。この1つずれる現象が重要だと考える。
        なぜなら、上式左辺のxの増加は右辺での引く量の増加に対応し、かつ論理否定は相互変換が容易で、!xがわかればxがわかるからである。
        そのため以下の式を考える。
        !(x+1)
        この式の論理否定を外せば以下の式が導けると思う。
        !(x+1) == -(x+2) == -x -2
        これは求めるべきx+1の論理否定が、-x と　-2がわかれば計算することができることを表している。
        前述の通り -1 を計算することは単純である。同様に　-2は　-1を2回繰り返すことで実現できそうだ。
        課題は-xである。

        しかし、これは(※)を利用すると作ることができる。
        (※)の式中のxを x == y-1 に置き換えると以下の式が導ける。
        !(y-1) == -y
        ゆえにyに-1を作用させて論理否定をすれば、yの補数、-yを計算することができる。
        +1する代わりに -1になっていることが重要。 +1が出る手順だと計算できない。
        
        以上からまとめると、
        !(x+1) == -x -2 == !(x-1) -1 -1

        x+1 == !{!(x-1) -1 -1}
        という式を得る。上記の式は、! -> Not16、 -1 == +(-1) -> Add16とtrueで実行可能である。
        ゆえに、インクリメンタは、Not16とAdd16という素子を使えば実装できそうである。
    */
    
    // x->inと実行部分では置き換える。
    // x + (-1) を実行する。
    Add16( a=in, b=true, out=in-1);

    // -x を計算する。
    Not16( in=in-1, out=negative-x);

    // -x -1 -1　を計算する。
    Add16( a=true,      b=true,       out=negative2);
    Add16( a=negative2, b=negative-x, out=inv-incx);

    // 最後に論理否定で全ビットを反転しx+1を得る。
    Not16( in=inv-incx, out=out);
```

## ALU実装メモ
実装のヒントより、手順は以下の通り。

1. nxとzxの違いによるxの出力の変更。
2. nyとzyの違いによるyの出力の変更。（1と同じと思われる）
3. fの値によってAnd演算かAdd演算か選択する。

また、回路仕様によればnx(or ny)とzx(or zy)の仕様は以下の通り。
- zx == 1 の時　xをゼロにする。
- nx == 1 の時　xを反転、!xにする。

fの値による仕様は以下の通りらしい。
- f == 1　の時、　出力をxとyの加算
- f == 0　の時、　出力をxとyのAnd

そのため、以下の手順で整理することを考える。
1. xのみの入出力について整理
2. 1.の内容をyに対して同様に実行。
3. xとyの相互演算について整理。(->これは勝手に決まるので考えなくてよかった。)

###  xのみの入出力について整理
#### xの状態を制御する。
|zx|nx|zy|ny|f|no|out|コメント|
|-|-|-|-|-|-|---|-------|
|0|0|1|1|0|0|x  |f==0かつno==0、noの値で出力はそのまま|
|0|0|1|1|0|1|!x |f==0かつno==1、noの値で出力を反転する|
|0|0|1|1|1|0|x-1|f==1かつno==0、noの値で出力はそのまま|
|0|0|1|1|1|1|-x |f==1かつno==1、noの値で出力を反転する|
|0|1|1|1|1|1|x+1|入力xを反転させて、最後にnoの値で出力を反転|

##### nxによるxの状態制御
以上を整理すると次の回路が必要だと思われる。  
- nx==1、no==1で入力を反転する-> ピン状態によって入力を論理否定かそのままかを制御する

これは論理的に簡単に導ける。入力をpとx、出力をoutとすると以下の表となる。
|p|out|
|-|---|
|0|in |
|1|!in|

よってこのゲートをInv_or_Notとすると、
```
    Inv_or_Not(p,in[16]) = !p*in + p*!in
```
とするとピン入力でバス入出力を制御できる。まず、nxによる制御を実装する。-> Inv_or_Not(nx,x\[16\])

##### zxによるゼロ化制御
nxによる制御を作ったのでこのタイミングでzxによる制御を作る。  
zxによる制御の仕様は、
- zx == 1 の時　xをゼロにする。

であるため、次の真偽値表となるはずだ。
|zx|out|
|--|---|
|0 |x  |
|1 |0  |

この真偽値表から次の式が導けるはずだ。実装をZero-or-Not(zx, x\[16\])とすると
```
    Zero-or-Not(zx, x[16]) = !zx*x
```
となる。これを次に実装する。

##### 真偽値表（xのみの）の全段完了。
真偽値表、全段のnxとzxによる制御が実装できた。そのため、xとnxとzxだけに依存する部分は作ることができた。  
次にfによる制御を作る。そのためにxで実装したものと同様のものをy側でも実装する。でなければxと定数の演算ができなくなる。

##### fによる加算・論理積選択制御
なるべく手前から作ったほうが楽なので、次はfによる制御を作る。fによる制御は、xとyの積に関する制御。  
xとyがこの回路に入るまでに、0など別の状態になるがこの回路の役割はそういったものを結果として受け取って、fによる値で加算および論理積を選択して実行することである。

また、前述で実装していたZero-or-NotとInv-or-Notを直列で接続していなかったので、  
Zero-or-Not -> Inv-or-Not の順番で接続する。

いま、yの値を考えない範囲で実装しているため、以下の真偽値表の条件の実装を考える。
|zx|nx|zy|ny|f|no|out|コメント|
|-|-|-|-|-|-|---|-------|
|1|0|1|0|1|0|0|zx,zyでx,yをゼロにして加算する|
|1|1|1|1|1|1|1|-1同士の足し算をして最後に反転して1を作る|
|1|1|1|0|1|0|-1| -1 + 0 を作ってそのまま出力する|
|0|0|1|1|1|0|x-1|f==1かつno==0、noの値で出力はそのまま|
|0|0|1|1|1|1|-x |f==1かつno==1、noの値で出力を反転する|
|0|1|1|1|1|1|x+1|入力xを反転させて、最後にnoの値で出力を反転|

yの値を考えないというよりは出力にyが出てこない場合を考えている。yの部分をうまく0や-1にして演算を作っていくのがミソだと思う。

- out=0をまず考える。  
    xとyをゼロにする、これはつまり{(zx,nx),(zy,ny)} = {(1,0),(1,0)}のピン入力をすることで実現可能。これはすでに実装済み。  
    Zero-or-Not -> Inv-or-Not の順で回路を接続しているので、ゼロにしてそのまま出力しているだけになる。  
    ゆえにそれぞれの出力をf==1の時に加算することができるようにすれば完成する。

- f==1の時、Add16の回路を使用する。  
    これはf==1とf==0を同時に実装したほうが簡単。なぜなら、Add16回路を選択かAnd16回路を選択すると考えるのではなく、両方の回路を通してfの値で結合すればいいだけだからだ。
    And16(x,y)とAdd16(x,y)をピン入力fで結合すれば、見かけ上の回路の切り替えは次の式で実装できそうだ。実装をoutput-select-fとして、
    ```
        output-select-f = !f*And16(x,y) + f*Add16(x,y)
    ```
    ゆえにこれを実装することで解決できると考えられる。

- noで反転する  
    fで演算方法の指定まで実装すれば、ついでにnoによる反転指定も実装する。  
    計算結果、output-select-fを反転するかどうかをnoで決定する。実装方法は先ほどと同じで、noで反転したものとしていないものを結合する。ゆえに以下を実装する。
    ```
        out = !no*output-select-f + no*!output-select-f
    ```
    no==1の時反転した答えを出すために上記の式となる。

- out=1を考える。  
    これはxを-1に、つまりゼロにして反転する、yも同様の操作をしそれぞれの和==-2の論理反転で1を作る。ゆえにそれぞれ実装済みである。  

- out=-1を考える。  
    out=1ができれば、作ることができる。ゆえに実装済み。

- out=x-1  
    xをそのまま、yはゼロにして反転して加算すれば可能。ゆえに実装済み。

- out=-x  
    -x==!x+1 である。同様に -x==!(x-1) である。  
    ゆえに、out=x-1を反転すれば-xを得る。よって実装済み。

- out=x+1  
    インクリメンタで迷走した別解がここで出てきた。  
    作り方としては、out=-xを作る際に一番初めのxの段階で反転すればいい。ゆえに実装済み。

#### xの制御完了
　以上で、出力にxが出て着て、yが出てこない部分が実装完了した。それと同時に、同様の実装をyにも施しているのでyの制御も完了した。  
本の内容的には、7種類の実装をきちんとすれば結果的に18種類の実装ができたことになるそうだ。

#### zr, ngの制御
　outの制御ができたので早速実験と行きたいが、outの状態によって出力が異なる2つの出力がある。それぞれを実装する。  

- zr  
    仕様は、
    ```
    if(out==0) zr=1;
    else       zr=0;
    ```
    である。outが0000 0000 0000 0000 であれば1を出力し、そうでなければ0を出力する。  
    ゆえに、すべての桁の論理和Orを実行し結果を論理否定すれば目的の答えが得られると考えられる。ゆえに、
    ```
        Or8Way( in[0..7]=out[0..7] , out=out_lb_or);
        Or8Way( in[0..7]=out[8..15], out=out_hb_or);
        Or( a=out_lb_or, b=out_hb_or, out=inv-zr);
        Not( in=inv-zr, out=zr);
    ```
    とすればうまくいくと思われる。(方針はこれだが実際の実装は違う。)

- ng  
    仕様は、
    ```
        if(out<0) ng=1;
        else      ng=0;
    ```
    これは負の数であるか判定するものだそうだ。ゆえにこれは単純で、最上位ビットを論理積で持ってきてそのまま出力すればいい。ゆえに
    ```
        And( a=out[15], b=true, out=ng);
    ```
    これで実装可能であると予想される。もしくは直接、15番ピン出力をしたほうがいいかもしれない。

### ALU実装完了（テスト2種含め完了）
始めは難しそうだと思ったが、著者の方が適切に設計してくれいているおかげて最低限のルールを守るように実装するだけで多くの機能が実装できた（個々に機能を確認していないが本を読む限り、入力の組み合わせをうまくすることで複数の機能を実現しているように設計したそうだ）。こういった機能をうまく組み合わせることで回路の単純化ができるので注意深く実装する必要があるが、かなり難しそうだ。もし自分で作るときは注意して設計したい。