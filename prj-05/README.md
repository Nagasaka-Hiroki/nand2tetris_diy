# 第5章
コンピュータアーキテクチャについて説明されている章。  
前章で注意しなければならない点をここでも記述する。

1. 先頭3ビットの役割（A命令とC命令の切り替え）
1. aビットの役割（データ-アドレス解釈切り替え）
1. dビットの役割（保存方法の指定）
1. jビットの役割（ジャンプ指定）

上記の実装については未だ完了していない。コンピュータアーキテクチャについて進めていくはずなので上記の実装がどのようにされていくか注意して読み進めなければならない。

## ポイントのメモ
### プログラム内蔵方式
現代のコンピュータにおける重要なもの。読んでいると意味的にはコンピュータの動作がメモリ上のデータ（プログラム）によって決定されれるということ。すなわちコンピュータの動作がハードウェアのみによって決まるのではなく、メモリ上のデータによって挙動が変わるということ。これの何がうれしいか想像でしかないが、プログラム内蔵方式以前の方式ではコンピュータの挙動を変えるためにはハードウェアの結線を変えて処理内容を変えなければならなかったと推測している。しかしプログラム内蔵方式ではプログラムというデータによってコンピュータの動作を変更することができるため、いちいち結線を変えなくとも良くなった。そういった理解をしている。  
またGoogleで調べるといいウェブページがあった。一応メモする。
> - [CPUの基礎知識（１）](https://www.comp.tmu.ac.jp/morbier/comparch/CPUbase1.htm#:~:text=%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E5%86%85%E8%94%B5%E6%96%B9%E5%BC%8F%E3%81%A8%E3%81%AF,%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%82%82%E3%81%A7%E3%81%8D%E3%82%8B%E3%80%82)  

### メモリマップドI/OとI/Oデバイス
メモリマップドI/Oという考え方によってデバイスはCPUから見るとメモリと同等であると考えることができる。そういった考え方。  

この本で取り扱うHackコンピュータではデバイスの数が決まっており、スクリーンとキーボードのみである。それゆえに、Hackコンピュータではデバイスを探すといった操作が不要である。なぜなら、デバイスとスクリーンのメモリアドレスは既知であるため、探す必要がないからである。コンピュータの本質的なところを学習するという意味では非常にありがたいことである。

しかし一般的なコンピュータでは違うと思う。場合によってはスクリーンは2つ以上あるし、USBメモリやUSBマウス、場合によってはカメラなどもありデバイスの種類はさまざまである。とりわけPCとして内蔵している分には問題ないが、現在ではキーボードもマウスもカメラも様々な機器がUSBデバイスとしてPCに接続される。その場合はどうなるのだろうか？（ここの話はみかん本に書いてあったはずなのでそっちを詳しく見たほうがいいだろう）  
そういった疑問を持たずにこのまま読み進めるのは危険だと思たので一応メモしておく。

### ROMの書き込み
　本を読んでいくとプログラムカウンタの出力がROMに入力され、入力されたアドレスのプログラム（機械語）がROMから出力されるとある。ROMであるためこのデバイスに対してCPUは書き込むことができない。本の説明でもROMにプログラムを読み込ませる仕組みをシミュレータにつける必要があると書かれている。本章の最後にゲーム機のゲームソフトは外部のカセットにあり、カセットは取り換え可能なROMであるといったことが書かれていた。その説明を聞いて非常に納得した。この説明で私の中ではHackコンピュータはほとんど昔のゲームの様なイメージを持った。昔のゲーム機はゲーム機本体にカセットを差し込んで遊んだ（今でもカセットはあるが、現在のゲーム機はカセットを入れなくても起動する。そのため別にROMを持っていると見える。昔のゲーム機は起動しなかった覚えがある。）。また本のいうようにゲームカセットはほとんどROMの役割を持っていると考えても納得が行く。

昔のゲーム（ゲームボーイ）のカセットなしの挙動が気になったので調べた。以下にリンクを貼る。
> - [https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q114399541](https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q114399541)  

この回答によれば、最初に音と任天堂のロゴが出るらしい。そのため昔のゲーム機には最低限のROMに音とロゴを表示する機能、ゲームカセットのゲームデータとゲームプログラムをロード？するようにしているのではないだろうか？もしROMを複数持ってもいいのであればゲームカセット側のROMとゲーム本体側のROMが両立できるためこの疑問はなくなると思われる。

ゲーム機の話（昔）であれば十分理解できると思うが、現代のPCとなれば話は別になる。現代のPCにおいてもROMはどこになるのだろうか？パソコンの構成的にROMが存在しそうなのはマザーボードのチップセットとintelの話であればCPUにも内蔵のチップセットがある。これらに相当するだろうか？現状不明である。本を読み進めるとヒントがあるかもしれないので今は疑問のままにするが、疑問を忘れないためにメモしておく。  
(PCが起動してOSを読み込むまでの流れを明確に説明できないのでそれを理解するといいだろうか？)

### *.hackファイル？
このファイルは機械語のファイルのように見える。各テストを実行するため機械語でこれをもとにCPUを動かしてテストするといった認識を持っている。

# 実装のメモ
実装の順番のメモ。

1. CPU
1. メモリ
1. コンピュータ

## CPU
 CPUは機械語を実行できるように注意して実装する。機械語の仕様は以下の通り。
```
    (1) A命令
    0vvv vvvv vvvv vvvv
    (2) C命令
    111a cccc ccdd djjj
```
C命令のcビットは非常に簡単でALUに対する演算の制御ビットである。  
aビットも演算の方法を指定するビットである。aビットはAレジスタの解釈で、a=0の時データレジスタ、a=1の時メモリとして解釈する。  
dビットはデータの保存方法。
jビットはジャンプの制御。現状の予測だとプログラムカウンタに対する制御だと思われる。

また、本の中にヒントがあって、HackのCPUはALUと3つのレジスタで構成され、3つのレジスタはデータレジスタ、アドレスレジスタ、プログラムカウンタであるそうだ。これでうまく構成できないだろうか？

いろいろ読み返すと、A命令でAレジスタに値を保存する方法を先に実装するのを先にしたほうがいいと直感的に感じたのでそれを実装する。また、Aレジスタの値の解釈、aビットによる制御はマルチプレクサを使えばうまくいくのではないだろうか？

CPUの入出力についてまとめると以下の表になると思う。

|入力| → ALU → |出力|
|-|-|-|
|inM\[16\]| | outM\[16\]|
|instruction\[16\]||writeM|
|reset||addressM\[15\]|
|||PC\[15\]|

それぞれのピン、バスの入力か出力かどうか、接続されている回路について考える。

|入出力            |方向|入力元・出力先|メモ|
|-----------------|----|-|-|
|inM\[16\]        |入力|RAM||
|outM\[16\]       |出力|RAM||
|instruction\[16\]|入力|ROM|入力されるのは機械語|
|writeM           |出力|RAM|RAMへのロードビット|
|reset            |入力|シミュレータ|プログラムカウンタを0にする|
|addressM\[15\]   |出力|RAM|RAMの保存・取り出し先指定ビット|
|PC\[15\]         |出力|ROM|次に実行するプログラムの番号を指定する|

おおよそ上記であると予想している。

### A命令の実装
```
    (1) A命令
    0vvv vvvv vvvv vvvv
```
これを実装するには先頭ビットによって制御する。そしてこれは機械語であるためこの制御ビットはinstructionからCPUに入っていく。

A命令であるためDレジスタは関係ない。Dレジスタの存在を考えずに実装する。  
またアセンブラを書いていてわかったことだが、Dレジスタに直接格納はできない、必ずAレジスタを経由するためまずはAレジスタを実装するのが先決だろう。

Aレジスタはメモリからのデータも受け取る。そのためCPUの入力のうちinstructionとinMの二つのどちらかを選択しなければならない。  
ゆえにCPUの入力部分の一部が推測できそうだ。2つの入力instructiionとinMはA命令によってinstructionを選択するということなので、2つの入力をマルチプレクサで選択すればいいだろう。

しかし、本の中に書かれいる参考回路図だと似たことをしたいるが若干違う。本の図のほうがスマートに処理している。そのため考え方を変える。アセンブラを思い出してそれを実行できる回路を考えたほうがよさそうである。

アセンブラでよくあるのはだいたい以下の内容（A命令とAレジスタに関して）
```
    @R0
    M=0
    @R1
    A=M
```
意外とA命令とAレジスタだけのコードは少ない。（というよりDレジスタをかなり多用する）  
先ほどの内容だと、メモリ入力と機械語入力を取捨選択してAレジスタに保存している。しかしそれを実行するとうれしくないことは上を見ればわかる。  
なぜなら、メモリ入力をAレジスタに保存することもあるからだ（逆もしかり）。ゆえに、前述の方法は良くないことはこのことからも説明できそうだ。

ではどうするか。ほとんど本の図の通りになりそうだがなるべく見ないように努めて考える。  
まずALUの出力とinstructionを取捨選択し、Aレジスタに代入しその後にメモリ出力との選択を行う。これをするとAレジスタからの出力は現在のメモリ出力のアドレスを表し、メモリからはAレジスタの値が指し示すアドレスの値を出力することができる。ゆえにこの方法がいいと思われる（図の通りになっているがなぜそうなるか説明できているはずなのでOKとする）  
また、こうすることでALUの出力をAレジスタに保存することができる。つまりこれは以下のアセンブラが使えることを意味している。
```
    A=D

    および

    A=A+1 , A=!A, A=-A, A=A-1 (ほかにもあるだろうか？)
```
そういった意味でもALU出力とinstructionを取捨選択することは結構重要なことであるとわかる（そういう認識だがOK？）

上記の回路によってAレジスタへの入出力はOKだと思うが肝心の制御ができていない。

ゆえに次はデコーダを作る。  

### A命令の時のデコーダ出力
デコーダは本によれば制御ビットを部分ごとに分解する操作だそう。やることは簡単で、以下のAとC命令
```
    (1) A命令
    0vvv vvvv vvvv vvvv (デコード)→　0 , vvvvvvvvvvvvvvv
    (2) C命令
    111a cccc ccdd djjj (デコード)→　1 , 11 , a , cccccc , ddd , jjj
```
を各意味ごとに分解するということ。また、いまA命令について実装しているため、C命令を実行させないように制御すれば十分であるということに注意して実装する。つまりA命令を実行する上でC命令を受けるところがどのような入力となれば都合がいいか考える。そうすれば実際の実装はC命令の実装時だけ考えればいいはずなので。

気になるのは、A命令を実行したときALUから何を出力するべきかである。0にすべきかAレジスタの値にするべきか。  

ひとまず0を出力すると考えて進めていく。ALUから0を出力するには入力のいかんにかかわらずC命令のcビット列を以下にする。
```
    cccc cc === 1010 10
```

ゆえに先頭の5つ目から10個めまでは、先頭ビットが0の時上のビットを出力する。

また、A命令の特徴として必ずジャンプしないという特徴がある（ジャンプできるのはC命令だけ）。ゆえに、jビットは以下の通りになる。
```
    jjj == 000 (No jump)
```

A命令の内容はAレジスタに値をセットすることが役割である。ゆえに誤った値を保存されては困る。今ALUの出力を0としているためこの値を保存するのは困る。C命令の中でレジスタの保存にかかわるのはdビットであるため、  
(修正：d1は1だった)
```
    ddd == 100 (出力をAレジスタに保存する)
```
こうすれば出力が何であれレジスタとメモリが影響を受けることはない。

C命令の中で明記していないのは残りはaビットであるがこれは今出力が0としているので関係ない。0と1どちらでもいいので今回は0とする。
```
    a == 0 (どっちでもいい)
```
このaビットにもし縛りがつくとするなら、A命令の時のALUの出力をAレジスタにしたときだろう(ALU out == A)。Aレジスタの時は0(データレジスタとして解釈）にして、dビットを100に設定しなければならない。そうしないと変な値をAレジスタとメモリに格納することになる。  
(またここで本の実装と違いができるかもしれないが、0をなるべく使ったほうが個人的にしっくりくるので今のままにする)

以上より、A命令が来た時の各回路への制御入力ビット列は以下の通りとなるはずだ。
```
    011a cccc ccdd djjj →  111, 0, 1010 10, 100, 000  //d1は0でなく1だった。
```
A命令を発行と同時にデコーダでこの指定の命令を発行すればC命令を実行せずにA命令だけが実行されるはずである。  
先頭の3ビットが011であるのは先頭ビットが0である方が回路の都合が良く、また便宜上そうなっているだけである。

ゆえにこの方法でできるデコーダとは、入力された命令がA命令だろうがC命令だろうか何かしらの命令として解釈し、命令を発行するという操作をすることになる。発行する内容はビット列の値や先頭ビットによって変わるだけである。

### C命令
これまでの内容を少し整理する。
```
    (1) 先頭ビットが0のとき、デコーダで次の命令を発行する。
    0110 1010 1010 0000 (特定のビット列)
    (2) 先頭ビットが1の時、デコーダで次のC命令を発行する。
    111a cccc ccdd djjj (任意の a,c,d,jによるビット列)
```
上記のようにA命令の時に特定の命令を発行することで回路全体でA命令かC命令か考えなくても良くなるはずだ。考えるべきは先頭のビットが何であるかだけであると思う。  
どちらの命令を発行するかは簡単でマルチプレクサを使うだけだと思う。

以降ビットの違いを明瞭にするためにC命令のビット列を
```
    i11a c1c2c3c4 c5c6d1d2 d3j1j2j3 
```
として記述する。また、以降に出てくるマルチプレクサはMux(a,b,sel)で、sel==0の時aが、sel==1の時bが出力される。  
上記のことを受けてデコーダを作る。入力instructionは長いのでinstに省略し、デコーダの最上位ビットをdec15、最下位ビットをdec00とすると以下になる。
```
    ※true==1, false=0
    i  | dec15 = inst[15]
    1  | dec14 = true //便宜上存在する。実際にはピンに入力しない。
    1  | dec13 = true //便宜上存在する。実際にはピンに入力しない。
       | 
    a  | dec12 = Mux(false , inst[12], inst[15])
       |
    c1 | dec11 = Mux(true  , inst[11], inst[15])
    c2 | dec10 = Mux(false , inst[10], inst[15])
    c3 | dec09 = Mux(true  , inst[09], inst[15])
    c4 | dec08 = Mux(false , inst[08], inst[15])
    c5 | dec07 = Mux(true  , inst[07], inst[15])
    c6 | dec06 = Mux(false , inst[06], inst[15])
       |
    d1 | dec05 = Mux(true  , inst[05], inst[15])
    d2 | dec04 = Mux(false , inst[04], inst[15])
    d3 | dec03 = Mux(false , inst[03], inst[15])
       |
    j1 | dec02 = Mux(false , inst[02], inst[15])
    j2 | dec01 = Mux(false , inst[01], inst[15])
    j3 | dec00 = Mux(false , inst[00], inst[15])
```

デコーダから出力される上位3つのビットは本質的な意味を持たないと思う（現時点では）。そのため各制御対象に入力として入るのはdec12 ~ dec00であると考えられる。

これでデコーダができた。ゆえに、入力instructionに対する対処は完了したと思う（A命令によるAレジスタへの保存、デコーダによるC命令の発行）  
また書くのが遅れたが入力inMについてもAレジスタのところで終了していると思う（Aレジスタとの入力選択）

#### 命令　先頭1ビット（デコーダからの出力）
　dec15 = inst\[15\]となっているが機械語入力をそのまま持ってこればいいと思う。また、このビットはAレジスタ手前のマルチプレクサに結線すればいいと思う。

#### 命令　先頭2~3ビット（デコーダからの出力）
　これらはどこにも入力しなくてもいいと思う。便宜上あるだけだと思う。

#### 命令　aビット（デコーダからの出力）
　これは、Aレジスタの解釈。ゆえにALU入力手前のマルチプレクサのselに入力すれば良いと思う。

#### 命令　cビット（デコーダからの出力）
　ALUにつなぐ。

#### 命令　dビット（デコーダからの出力）
　保存方法について指定する。d1はAレジスタ、d2はDレジスタ、d3はメモリ（RAM）。  
ゆえに、それぞれのloadに接続すればいいと思う。また、d3はメモリに対してなので、これはCPU出力のwriteMになるはずだ。  
また、A命令を実装していたためDレジスタを考えていない。しかしDレジスタは直接代入できないこと、ALUからの出力を保存できることを考えると、DレジスタはALU出力から入力を受けてALUに対して出力をするレジスタとして実装すればよさそうである。

#### 命令　jビット（デコーダからの出力）
　ジャンプについて指定する。そのためプログラムカウンタに対する制御をする。プログラムカウンタの入力は4つ、アドレス入力、reset, load, inc。そして出力としてアドレスを出力する。  
ここで各入力は、アドレスはAレジスタから入力される。resetは外部から入力されるのでCPU内では結線しない、loadはジャンプするときに入力アドレスをセットするときに使う。そしてincはジャンプしないときに使用する。

ゆえに、プログラムカウンタを制御するのはCPU内ではloadとincの二つになる。ゆえにjビットはALU出力をもとにloadとincどちらをtrueにするか計算する必要がある。

ALUはout<0とout==0を判定するピン出力ng,zrが存在する。ゆえにこれをうまく使ってジャンプを作るはずだが、その前に小なりと等しいを使って比較演算全体を作る。表中の!は論理否定を表す。

|比較演算|組み合わせ（ <, ==) | 結果が真になる組み合わせng,zr |　→　計算式     |
|--------|------------------|-----------------------------|---------------|
|   <    |         <        |            ng==1            |    ng         |
|   <=   |      < or ==     |         ng==1 or zr==1      |    ng +  zr   |
|   ==   |         ==       |            zr==1            |    zr         |
|   >=   |         !<       |            ng==0            |   !ng         |
|   >    |    !< and !=     |        ng==0 and zr==0      |   !ng * !zr   |
|   !=   |         !=       |            zr==0            |   !zr         |

ジャンプ指定は上記の比較演算に加えて無条件にジャンプと無条件にジャンプしないの2つが加わる。

ジャンプビットの組み合わせで上記の表の対応をとると、無条件の計算結果をfalseとtrueにしてjビットで切り替えをするようにすれば以下の表になる。

|   j1 (out<0)  |   j2  (out=0) |   j3 (out>0)  |   ジャンプの仕方   |計算式|load|inc|ピン名|
|---------------|---------------|---------------|-------------------|-----|----|---|------|
|0|0|0|無条件にジャンプしない | false   |0            |1             |NJP|
|0|0|1| >　が真の時          |!ng * !zr|if f 1 else 0|if f 0 else 1 |JGT|
|0|1|0| ==が真の時           |zr       |if f 1 else 0|if f 0 else 1 |JEQ|
|0|1|1| >=が真の時           |!ng      |if f 1 else 0|if f 0 else 1 |JGE|
|1|0|0| < が真の時           |ng       |if f 1 else 0|if f 0 else 1 |JLT|
|1|0|1| !=が真の時           |!zr      |if f 1 else 0|if f 0 else 1 |JNE|
|1|1|0| <=が真の時           |ng + zr  |if f 1 else 0|if f 0 else 1 |JLE|
|1|1|1|無条件にジャンプする   | true    |1            |0             |JMP|

ゆえに、3段のマルチプレクサを使えば良いと思う。
- 1段目

|内部ピン名|回路名およびピン名|sel|出力ピン|
|---------|----------------|----|-------|
|NJP      |Mux a           |j1  |Mux0 |
|JLT      |Mux b           |j1  |Mux0 |
|JGT      |Mux a           |j1  |Mux1 |
|JNE      |Mux b           |j1  |Mux1 |
|JEQ      |Mux a           |j1  |Mux2 |
|JLE      |Mux b           |j1  |Mux2 |
|JGE      |Mux a           |j1  |Mux3 |
|JMP      |Mux b           |j1  |Mux3 |

- 2段目

|内部ピン名|回路名およびピン名|sel|出力ピン|
|---------|----------------|----|-------|
|Mux0     |Mux a           |j2  |Mux02  |
|Mux2     |Mux b           |j2  |Mux02  |
|Mux1     |Mux a           |j2  |Mux13  |
|Mux3     |Mux b           |j2  |Mux13  |

- 3段目

|内部ピン名|回路名およびピン名|sel|出力ピン|
|---------|----------------|----|-------|
|Mux01    |Mux a           |j3  |load   |
|Mux23    |Mux b           |j3  |load   |

- incビット
incビットはloadビットの反転とすればうまくいきそうだ。

これでjビットのデコードができそうだ。

### 機械語の対応完了
機械語の各ビットに対するデコードができた。すなわち、
```
    (1) A命令
    0vvv vvvv vvvv vvvv
    (2) C命令
    111a cccc ccdd djjj
```
を処理する論理演算回路を組む方法がわかった。あとは理解に従って.hdlファイルを作成する。
またデコーダ以外のCPU回路は本の提案図と同じになったが、なぜそうなったか理解できているのでOKとして進める。

また、レジスタは章の末尾の説明の通りARegisterとDRegisterを使おうと思う。（普通のレジスタを使ったらテストではじかれた…。）

## メモリ
メモリは1．メモリ、2．スクリーン、3．キーボードの3つで構成される。

メモリのサイズは、
1. メモリ　　　→　0～16283　   (16,384) → RAM16K × 1
2. スクリーン　→　16384～24575 ( 8,192) → RAM4K  × 2
3. キーボード　→　24576        (     1) → Register × 1

と考えていたが途中でスクリーンはスクリーンで使えること、同様にキーボードの回路があったのでそちらを使う。しかしコード中の文字列は変更せずに続ける
読み替えは ram-4kがScreenでrgがKeyboadである。個人的にメモリとして実装しておいて、そのメモリ領域とやり取りすると思っていたのだがそうではないそうだ。  
しかし、テストはOKだったのでよしとする。

## コンピュータ
ROMはビルトインチップがあるそうなのでそれと接続する。そしてこれまで作ったCPUとメモリを結合してHackコンピュータを完成させる。

ここはCPUに比べれば単純であると思う。というよりは本中の実装案そのものだと思う。ここはそこまで複雑でないと思うので深く考えず進める。

### テスト完了
用意されているテストをすべて問題なくクリアできた（End of Scriptと最後に全部出てくれた）。  
これでHackコンピュータの構成（NandからComputer）が完了した。本のページ的にはまだまだ半分過ぎていないのでこれからも頑張りたい。

# 5章完了
非常に時間がかかったが5章　コンピュータアーキテクチャを終了した。  
機械語の解釈が非常に難しかった。A命令、C命令となっているところから共通の命令を作成しA命令の時はALUの動きを抑えてうまく実行できるようにするといった発想を思いつくのに時間がかかったし、ジャンプビットの整理にも非常に時間がかかった。しかし非常に楽しかったし、機械語に対する理解が深まった。また、プログラムカウンタやメモリについても理解が深まったと思うのでこの5章は非常に勉強になったと感じる。  
(というよりもハードウェアの最終章？のように感じたのでそれゆえに内容が重くなったのだろうか)