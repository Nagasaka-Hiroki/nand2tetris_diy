# 第4章
Hackコンピュータの機械語について詳細に触れている章。現状、機械語とISAの違いや包含関係が明瞭でないが現段階の理解について整理する。  

また、整理するために機械語の各ビットの役割について整理する。良く調べてみると意外とネット上にも詳しく書かれているのがあったので一応リンクだけ貼っておく。
> - [https://www.csie.ntu.edu.tw/~cyy/courses/introCS/20fall/lectures/handouts/lec09_HackArch_4up.pdf](https://www.csie.ntu.edu.tw/~cyy/courses/introCS/20fall/lectures/handouts/lec09_HackArch_4up.pdf)
> - [https://en.wikipedia.org/wiki/Hack_computer](https://en.wikipedia.org/wiki/Hack_computer)

これまでで作ってきたALUより、本で作っているコンピュータは16ビットである。ゆえに機械語も16ビットになる。ビット数が多ければ一度の命令文で実行できるが、16ビットだと難しく本によればあらゆる命令が2組で一つの命令となっている（私の理解だとそう思っているが、解釈が違う？※）。そして2組の命令はそれぞれ (1) A命令、　(2) C命令　である。それぞれの命令はざっくりと以下の通りであると理解している。
1. A命令  
    Aレジスタに値を格納する命令。  
    Hackコンピュータでは、レジスタは2つだけである。それぞれ、AレジスタとDレジスタである。Dレジスタはデータを保存する機能を持っている。そしてAレジスタはデータを保持する点はDレジスタと同様であるが、保持したデータを、データとして解釈するか？メモリアドレスとして解釈するか？選択することができる。この機能によりデータをメモリから取得して演算することができる。  
    書式は、先頭ビット（MSB)が0の時、A命令とするそうだ。そのため、メモリアドレスは15ビットのアドレスになる。
1. C命令  
    演算命令。演算の内容は算術演算、論理演算、ジャンプ（Goto)である。現状の理解では前述の3つである（ジャンプはうまい単語が見つからなかったので動作をそのまま書いた）。なお、ジャンプは比較演算の結果でジャンプ先が変わるので、ジャンプは比較演算と解釈することもできると思う。  
    書式は、aビット、cビット、dビット、jビットの3種類で構成される。最初の1ビットはA命令と逆で1の時にC命令と解釈され、それに続く2ビットも常にC命令では1に設定される。そのため残りの13ビットで演算内容について指定する。それぞれの意味は以下の通りだと思う。  
    - aビット　→　Aレジスタ解釈方法の指定。a=0の時データとして、a=1の時メモリアドレスとして解釈してメモリアドレス上の値として演算する。a=1とすることでDアドレスだけの演算と定数演算（0,1,-1,Dなど)ができないくなるみたい。  
    - cビット　→　6桁のcビットで構成される。ビットの組み合わせによってDレジスタとAレジスタの演算方法を決定する。注意深く見ると演算内容がa=0の時の仕様と、ALUを実装するときに見た表が同一であることがわかる。ゆえにこの機械語はALUに対する入力として作用することが想像できる。
    - dビット　→　演算結果の保存方法について指定する。  
    保存先は3つ、Dレジスタ、Aレジスタ、Aレジスタが指し示すメモリ。それぞれについて指定する。また、ビットは合計3ビット割り当てられているため、これら3つに対するすべての組み合わせについて保存が可能である。  
    - jビット　→　ジャンプ条件について指定するビット。合計3ビット割り当てられている。    
    数学的？には比較演算は0に対して、(1)大なり ' > ' (2) 大なりイコール ' >= ' (3) 等しい　' == ' (4) 小なりイコール '<=' (5) 小なり ' < ' (6) 等しくない ' != ' が定義されていればあらゆる数に対する比較演算ができるはず（左辺に移項して右辺を0にしてゼロに対する比較に演算を置き換える）。加えて無条件にジャンプする、または無条件にジャンプしないを加えた合計8通りあればジャンプ命令としては十分であると考えられる。そのため、3ビットあればあらゆるジャンプ命令を書くことができるはずだと思う。  

※実装完了して感じたこと  
実装完了後にこの文章を読むと解釈が少し違うと思った。厳密には、2つの命令になることもあるし1つの命令となることもあるが正しい。なぜなら、すでにレジスタに必要な値がある場合無理にA命令を実行する必要はないからだ。実際、A命令で使うのはAレジスタだけなので当然必要なデータがAレジスタ上にある時は一度Dレジスタに逃がしてA命令でデータを取得しなければならない。しかし先に演算が終わった状態でDレジスタに値があるときは必要ない、こういう状況はあったためこの解釈で間違いはないと思われる。

4章を読むとおおよそ上記の内容に加えHackコンピュータに対する機械語の書き方について解説されている。しかし、注意しなければならないのは、機械語の中でこれまでに明らかにされているのはC命令のcビットのふるまいのみであるということ。機械語の各ビットに対して、
1. 先頭3ビットの役割（A命令とC命令の切り替え）
1. aビットの役割（データ-アドレス解釈切り替え）
1. dビットの役割（保存方法の指定）
1. jビットの役割（ジャンプ指定）

の挙動については定義されていない。現在は本の先頭から読み進める方法をとっているため読み方が悪いだけかもしれないが、どの章から読み進めてもいいように書かれていると前書き？で書いていたと思うので問題はないと思う。

また、この不明を理解するためにISAについての知識があれば解決すると思ったので自分に説明してみる。内容は過去に調べて学んだ知識をアウトプットするもののためソースの明記は難しいが、ブックマークを簡単にたどったところ次の2つが出てきたので一応メモしておく。  
- [https://sylph.fuis.u-fukui.ac.jp/~moris/lecture/ARC/2020/ISA.pdf](https://sylph.fuis.u-fukui.ac.jp/~moris/lecture/ARC/2020/ISA.pdf)  
- [https://www.am.ics.keio.ac.jp/parthenon/isa.pdf](https://www.am.ics.keio.ac.jp/parthenon/isa.pdf)

ISAとは、機械語の仕様について定めたものである。ゆえに今回のケースだとA命令、C命令それぞれはただの機械語である。しかし、A命令、C命令を合わせれば機械語の仕様を表していると見ることができるためISAであるということができるのではないだろうか（ここは要検証である）。  
そして、ISAの重要な点はあくまで機械語（0と1の組み合わせによるビット列）と挙動（演算内容など）の対応を表しているだけであるということ。そのため、ソフトウェア開発者は目標とする挙動を機械にされるために挙動に対応する機械語を生成させることに注力すればよく、ハードウェア開発者は各ビット列が表す挙動を満足する回路を設計・実装することに注力すればよいことになる。それゆえにISAはハードウェアとソフトウェアの出発点であると解釈することも可能であると考えられる。

ではこのISAの知識が今の疑問に対してどのように影響するのか。  
考え方としてはソフトウェア開発者として考えるか？ハードウェア開発者として考えるか？の2通りで理解できると思う。（といっても片方は考えないという解決だが…。）

最も簡単な理解は、ソフトウェア開発者として考えることである。  
なぜなら、ISAの仕様にしたがって実装されたハードウェアを使用してプログラムを作成するからである。ソフトウェア開発者が見るべき最も低いレイヤはISAであり、それ以降はハードウェア開発者がISAのルールを満足するようにハードウェアを作ってくれるからである。この考え方は本のかなり序盤に出てきた抽象化という考え方である。より低いレイヤを見るときには抽象化（だいたいブラックボックス化）することで理解するという立場で見るといいといった趣旨が書かれている。その考え方にのっとった理解である。そして重要なのはこの考え方をしないとこの章の課題ができないということだ（課題を後回しにしてCPUの実装を先に学べば別の話であるが）。そのためこの考え方によりソフトウェア開発に注力するできる（と理解している）。（普通にブラックボックス化して理解するといったほうがわかりやすいかもしれないが、考えを整理するために長々と書いた）

その次は、ハードウェア開発者として考えることである。  
前述の通り、ISAの仕様を満足するようにハードウェア開発者は設計をする。そして、現状CPU自体は設計していない。設計しているのはALUやメモリ、プログラムカウンタやレジスタであってCPUとして未だ構築していないのでその疑問はもっともなものである。ゆえにISAの仕様を満足するように素子を組み合わせてCPUの設計をこれからしていく（はず…。）。未だ先の章を読んでいないので断定できないがこれからCPUについて構築していくと勝手に想像している。

## 実装のメモ
操作手順のメモ
1. アセンブラとCPUエミュレータを使えるようにする。  
    1. 以下のコマンドを実行
    ```
        cd /usr/local/bin
        sudo ln -s /path to tools directory/CPUEmulator.sh CPUEmulator
        sudo ln -s /path to tools directory/Assembler.sh   Assembler
    ```
    2. 実行の確認
    ```
        CPUEmulator
        Assembler
    ```
    起動するか確認してみた。（その前にx-serverを起動してGUIアプリを実行できるようにする）  
    問題なく起動できた。これで準備はOK。
1. ダウンロードしたファイルからひな形を持ってくる。
1. アセンブラチュートリアルとCPUエミュレータチュートリアルを見る（ざっくりと）。
> - [CPU Emulator Tutorial](https://www.nand2tetris.org/_files/ugd/44046b_f63aba2611944e82974c9c5d5a3821fe.pdf)
> - [Assembler Tutorial](https://www.nand2tetris.org/_files/ugd/44046b_759f4f811ad14e12ac45bc60dd679fa3.pdf)
4. まず、乗算プログラムから取り組む。
4. Mult.asmを編集して解答する。
4. アセンブラでエラーがないか確認して、エミュレータでシミュレーションする。
4. 次はFill.asmを取り組む。
4. 完了

## 実装完了
画面の塗り方が難しいと感じた。というよりは私の読解力がないだけのような気がするが。しかし、しっかり解答でき、テストもクリアできたのでOKとする。

## 細かいことのメモ
### 掛け算
掛け算は足し算の繰り返しと思って以下を実装したがうまくいかないかった。見直してみる  
```
//R0,R1は入力
//R2は出力

//まず、× 0になっていないか確認する。
    @0
    D=M
    @END
    D;JEQ

    @1
    D=M
    @END
    M;JEQ

//掛け算は足し算になるので、足し算を繰り返す
//まずR2を0にする。
    @0
    D=A
    @2
    M=D

(LOOP)
    //DレジスタにR0の内容を保存
    @0
    D=M
    //R2にDレジスタを加算
    @2
    M=M+D
    //R1をデクリメントする
    @1
    M=M-1
    //R1の値が0かでジャンプする。
    @1
    D=M
    @END
    D;JEQ

//Hackコンピュータでは最後は無限ループにする。
(END)
    @END
    0;JMP
```
(見直すと負の数の場合を考慮できていない)->本を読み直すと値は必ず正の値らしい。しかし、完成したものは負の値の掛け算も可能であるためこのままにしておこう（テストも問題なく成功できたので）

演算方法一覧を見ると、-Aとかのように入力値をマイナスにしたものが計算できる。  
ゆえに、正の値同士で計算し結果を負にすることで正×負を表現するということを考える。

また、仮想レジスタを使うとわかりやすく書けそうだ。仮想アドレスはR0~R15が使えるらしい。  
R0, R1, R2は入出力で使うので、  
```
    R3 ←　R0の絶対値を格納する。
    R4 ←　R1の絶対値を格納する。
```
として計算準備をするとして進める。

シミュレーションの速度をあげすぎると停止するので程よい速度にする。そのままでも出るときがある（無限ループのところの繰り返しが多いとそうなる？）  
確認のために完成後最速で実行してみたところ、なんのエラーもなく終了した。なんだろう？

## 入出力操作
難しかった点は次の書き方。
```
    //描画するスクリーンの画素を取得し色を塗る
    @R1
    A=M // ←ここ
    M=D
```
Aレジスタに登録したメモリアドレスをAレジスタに保存して、その状態でメモリアドレス先のデータを操作する。イメージだとポインタのポインタだろうか？ここができずに画面がずっと白だった。

また、気づかなかったが黒で塗るときは1であると本で書いていたので1にしたが、厳密には16ビットのビット列として指定しなければならないので、厳密に画面を黒くするには-1と指定しなければならないところだった。その影響で画面が縞々になっていた。

